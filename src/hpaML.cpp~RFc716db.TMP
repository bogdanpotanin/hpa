#include "hpaMain.h"
#include "hpaML.h"
#include "polynomialIndex.h"
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace RcppArmadillo;
// [[Rcpp::depends(RcppArmadillo)]]

//' Perform semi-nonparametric maximum likelihood estimation
//' @template x_ML_Template
//' @template pol_degrees_Template
//' @template tr_left_Template
//' @template tr_right_Template
//' @template given_ind_Template
//' @template omit_ind_Template
//' @template x0_ML_Template
//' @details 
//' @template hpa_likelihood_details_Template
//' @template GN_details_Template
//' @template first_coef_Template
//' @template sd_adjust_Template
//' @return This function returns an object of class "hpaML".\cr \cr
//' An object of class "hpaML" is a list containing the following components:
//' \itemize{
//' \item \code{optim} - \code{\link[stats]{optim}} function output.
//' \item \code{x1} - numeric vector of distribution parameters estimates.
//' \item \code{mean} - the same as \code{mean} input parameter.
//' \item \code{sd} - adjusted \code{sd} parameter.
//' \item \code{pol_coefficients} - the same as \code{pol_coefficients} input parameter.
//' \item \code{tr_left }- the same as \code{tr_left} input parameter.
//' \item \code{tr_right} - the same as \code{tr_right} input parameter.
//' \item \code{omit_ind }- the same as \code{omit_ind} input parameter.
//' \item \code{given_ind} - the same as \code{given_ind} input parameter.
//' \item \code{cov_matrix} - estimated parameters covariance matrix.
//' \item \code{results} - numeric matrix representing estimation results.
//' \item \code{log-likelihood} - value of Log-Likelihood function.
//' \item \code{AIC} - it is AIC value.
//' \item \code{data} - the same as \code{x} input parameter but without \code{NA} observations.
//' \item \code{n_obs} - number of observations.}
//' This object has overloadings for summary and predict methods: \link[hpa]{summary.hpaML} and \link[hpa]{predict.hpaML} correspondingly.
//' @examples
//' ##Approximate student (t) distribution
//' #Simulate 1000 realizations of student distribution with 5 degrees of freedom
//' n <- 1000
//'	df <- 5
//'	x <- matrix(rt(n, df), ncol = 1)
//'	pol_degrees <- c(4)
//'	#Apply pseudo maximum likelihood routine
//'	ml_result <- hpa::hpaML(x = x, pol_degrees = pol_degrees)
//' summary(ml_result)
//' #Get predicted probabilites (density values) approximations
//' predict(ml_result)
//' 
//' ##Approximate chi-squared distribution
//' #Simulate 1000 realizations of chi-squared distribution with 5 degrees of freedom
//' #setting lower truncation point at sample minimum realization
//' n <- 1000
//'	df <- 5
//'	x <- matrix(rchisq(n, df), ncol = 1)
//'	pol_degrees <- c(1)
//'	tr_left <- as.vector(min(x))
//'	tr_right <- as.vector(max(x))
//'	#Apply pseudo maximum likelihood routine
//'	ml_result <- hpa::hpaML(x = x, pol_degrees = as.vector(pol_degrees), 
//'					tr_left = as.vector(tr_left),
//'					tr_right = as.vector(tr_right))
//' summary(ml_result)
//' #Get predicted probabilites (density values) approximations
//' predict(ml_result)
//' @export
// [[Rcpp::export]]
List hpaML(NumericMatrix x,
	NumericVector pol_degrees = NumericVector(0),
	NumericVector tr_left = NumericVector(0),
	NumericVector tr_right = NumericVector(0),
	LogicalVector given_ind = LogicalVector(0),
	LogicalVector omit_ind = LogicalVector(0),
	NumericVector x0 = NumericVector(0)) {

	//Load additional environments

	//Add in future
	//Rcpp::Environment stats_env("package:optimParallel");
    //Rcpp::Function optim = stats_env["optimParallel"];

	Rcpp::Environment stats_env("package:stats");
	Rcpp::Function optim = stats_env["optim"];
	Rcpp::Function na_omit_R = stats_env["na.omit"];

	Rcpp::Environment base_env("package:base");
	Rcpp::Function solve = base_env["solve"];
	Rcpp::Function c_R = base_env["c"];

	//remove na values

	x = na_omit_R(x);

	//Initialize additional index for some loops

	int k = 0;
	
	//Initialize polynomial structure related values

	int pol_degrees_n = pol_degrees.size();

	int pol_coefficients_n = 1;

	for (int i = 0; i < pol_degrees_n; i++)
	{
		pol_coefficients_n *= (pol_degrees[i] + 1);
	}

	pol_coefficients_n -= 1; //because a(0...0)=1

	//Initialize conditions and marginals

	if (given_ind.size() == 0)
	{
		given_ind = LogicalVector(pol_degrees_n);
	}

	if (omit_ind.size() == 0)
	{
		omit_ind = LogicalVector(pol_degrees_n);
	}

	//Create initial values vector
	bool x0_given = true;

	if (x0.size() == 0)
	{
		x0_given = false;
		x0 = NumericVector(pol_coefficients_n + 2 * pol_degrees_n);
	}

	//Assign indexes

		//for polynomial coefficients
	
	NumericVector pol_coefficients_ind(pol_coefficients_n);

	for (int i = 0; i < pol_coefficients_n; i++)
	{
		pol_coefficients_ind[i] = i;
	}

		//for mean vector

	NumericVector mean_ind(pol_degrees_n);

	for (int i = pol_coefficients_n; i < (pol_coefficients_n + pol_degrees_n); i++)
	{
		mean_ind[k] = i;
		if (!x0_given)
		{
			x0[i] = mean(x(_, k));
		}
		k++;
	}
	
		//for sd vector

	k = 0;

	NumericVector sd_ind(pol_degrees_n);

	for (int i = (pol_coefficients_n + pol_degrees_n); i < (pol_coefficients_n + 2 * pol_degrees_n); i++)
	{
		sd_ind[k] = i;
		if (!x0_given)
		{
			x0[i] = sd(x(_, k));
		}
		k++;
	}

	//Deal with truncation

	NumericMatrix tr_left_mat(1,pol_degrees_n);
	NumericMatrix tr_right_mat(1,pol_degrees_n);

	if ((tr_left.size() > 0) | (tr_right.size() > 0))
	{
		if (tr_left.size() == 0)
		{
			tr_left = (pol_degrees_n, R_NegInf);
		}

		if (tr_right.size() == 0)
		{
			tr_right = (pol_degrees_n, R_PosInf);
		}

		tr_left_mat(0, _) = tr_left;
		tr_right_mat(0, _) = tr_right;
	}
	else
	{
		std::fill(tr_left_mat.begin(), tr_left_mat.end(), NA_REAL);
		std::fill(tr_right_mat.begin(), tr_right_mat.end(), NA_REAL);
	}
	
	//Apply optimization routine

	List PGN_control = List::create(Named("maxit") = 100000);

	List optim_results = optim(
		Rcpp::_["par"] = x0,
		Rcpp::_["fn"] = Rcpp::InternalFunction(&hpaLnLOptim),
		Rcpp::_["control"] = PGN_control,
		Rcpp::_["method"] = "BFGS",
		Rcpp::_["hessian"] = true,
		Rcpp::_["x"] = x,
		Rcpp::_["pol_coefficients_ind"] = pol_coefficients_ind,
		Rcpp::_["pol_degrees"] = pol_degrees,
		Rcpp::_["given_ind"] = given_ind,
		Rcpp::_["omit_ind"] = omit_ind,
		Rcpp::_["mean_ind"] = mean_ind,
		Rcpp::_["sd_ind"] = sd_ind,
		Rcpp::_["is_minus"] = true, //true because of minimization
		Rcpp::_["tr_left"] = tr_left_mat,
		Rcpp::_["tr_right"] = tr_right_mat); 

	//Extract optimization results

	NumericVector x1 = optim_results[0];

	double lnL = optim_results["value"];
	lnL = lnL * (-1);

	int x1_n = x1.size();

	NumericVector mean = x1[mean_ind];

	NumericVector sd = x1[sd_ind];

	NumericVector pol_coefficients = x1[pol_coefficients_ind];
	pol_coefficients.push_front(1);

	NumericMatrix cov_mat = solve(optim_results["hessian"]);

	//Prepare beautifull results output

	NumericMatrix results(x1_n, 3);

	StringVector results_cols = StringVector::create("Estimate", "Std. Error", "P(>|z|)");

	StringVector results_rows(x1_n);

	NumericMatrix pol_ind = polynomialIndex(pol_degrees);

		//for polynomial coefficients

	for (int i = 1; i < (pol_coefficients_n + 1); i++)
	{
		results_rows[(i - 1)] = "a";
		for (int j = 0; j < pol_degrees_n; j++)
		{
			//Convert double to string
			int my_int = pol_ind(j, i);
			std::stringstream ss;
			ss << my_int;
			std::string str2 = ss.str();
			//
			results_rows[(i - 1)] = as<std::string>(results_rows[(i - 1)]) + "_" + str2;
		}
		results((i - 1), 0) = pol_coefficients[i];
		results((i - 1), 1) = sqrt(cov_mat((i - 1), (i - 1)));
		double t_stat = results((i - 1), 0) / results((i - 1), 1);
		NumericVector F_t_stat = pnorm(NumericVector::create(t_stat));
		results((i - 1), 2) = 2 * std::min(F_t_stat[0], 1 - F_t_stat[0]);
	}

		//for mean
	for (int i = 0; i < pol_degrees_n; i++)
	{
		if (pol_degrees_n == 1)
		{
			results_rows[mean_ind[i]] = "mean";
		}
		else
		{
			results_rows[mean_ind[i]] = "mean_" + std::to_string(i + 1);
		}
		results(mean_ind[i], 0) = x1[mean_ind[i]];
		results(mean_ind[i], 1) = sqrt(cov_mat((mean_ind[i] - 1), (mean_ind[i] - 1)));
		double z_stat = results(mean_ind[i], 0) / results(mean_ind[i], 1);
		NumericVector F_z_stat = pnorm(NumericVector::create(z_stat));
		results(mean_ind[i], 2) = 2 * std::min(F_z_stat[0], 1 - F_z_stat[0]);
	}

		//for sd
	for (int i = 0; i < pol_degrees_n; i++)
	{
		if (pol_degrees_n == 1)
		{
			results_rows[sd_ind[i]] = "sd";
		}
		else
		{
			results_rows[sd_ind[i]] = "sd_" + std::to_string(i + 1);
		}
		results(sd_ind[i], 0) = x1[sd_ind[i]];
		results(sd_ind[i], 1) = sqrt(cov_mat((sd_ind[i] - 1), (sd_ind[i] - 1)));
		double z_stat = results(sd_ind[i], 0) / results(sd_ind[i], 1);
		NumericVector F_z_stat = pnorm(NumericVector::create(z_stat));
		results(sd_ind[i], 2) = 2 * std::min(F_z_stat[0], 1 - F_z_stat[0]);
	}

		//assign names

	rownames(results) = results_rows;

	colnames(results) = results_cols;

	x1.names() = results_rows;

	rownames(cov_mat) = results_rows;
	colnames(cov_mat) = results_rows;

	LogicalVector pol_coefficients_names = c_R("a_0", results_rows[pol_coefficients_ind]);

	pol_coefficients.names() = c_R("a_0", results_rows[pol_coefficients_ind]);

		//collect the results

	List return_result = List::create(Named("optim") = optim_results, Named("x1") = x1,
		Named("mean") = mean, Named("sd") = sd,
		Named("pol_coefficients") = pol_coefficients, Named("pol_degrees") = pol_degrees,
		Named("tr_left") = tr_left_mat, Named("tr_right") = tr_right_mat,
		Named("omit_ind") = omit_ind, Named("given_ind") = given_ind,
		Named("cov_matrix") = cov_mat,
		Named("results") = results, 
		Named("log-likelihood") = lnL, Named("AIC") = 2 * (x1_n - lnL),
		Named("data") = x,
		Named("n_obs") = x.nrow());

	return_result.attr("class") = "hpaML";

	return(return_result);
}

//' Perform  log-likelihood function estimation for Phillips-Gallant-Nychka distribution at point
//' @template x_ML_Template
//' @template pol_degrees_Template
//' @template tr_left_Template
//' @template tr_right_Template
//' @template given_ind_Template
//' @template omit_ind_Template
//' @template mean_Template
//' @template sd_Template
// [[Rcpp::export]]
double hpaLnL(NumericMatrix x = NumericMatrix(1, 1), 
	NumericVector pol_coefficients = NumericVector(0),
	NumericVector pol_degrees = NumericVector(0), 
	LogicalVector given_ind = LogicalVector(0),
	LogicalVector omit_ind = LogicalVector(0),
	NumericVector mean = NumericVector(0),
	NumericVector sd = NumericVector(0))
{
	return(sum(log(dhpa(x,
		pol_coefficients, pol_degrees,
		given_ind, omit_ind,
		mean, sd))));
}

//' Perform  log-likelihood function estimation for Phillips-Gallant-Nychka distribution at point
//' @template x0_ML_Template
//' @template x_ML_Template
//' @template pol_coefficients_Template
//' @template pol_degrees_Template
//' @template given_ind_Template
//' @template omit_ind_Template
//' @template mean_Template
//' @template sd_Template
//' @param is_mimus bool indicating wheather likelihood function should be multuplied by -1.
//' @template tr_left_Template
//' @template tr_right_Template
//' @details This method is adopted for optimization routine.
// [[Rcpp::export]]
double hpaLnLOptim(NumericVector x0,
	NumericMatrix x = NumericMatrix(1, 1),
	NumericVector pol_coefficients_ind = NumericVector(0),
	NumericVector pol_degrees = NumericVector(0),
	LogicalVector given_ind = LogicalVector(0),
	LogicalVector omit_ind = LogicalVector(0),
	NumericVector mean_ind = NumericVector(0),
	NumericVector sd_ind = NumericVector(0),
	bool is_minus = false,
	NumericMatrix tr_left = NumericMatrix(1, 1),
	NumericMatrix tr_right = NumericMatrix(1, 1))
{

	NumericVector mean = x0[mean_ind];

	NumericVector sd = x0[sd_ind];

	NumericVector pol_coefficients = x0[pol_coefficients_ind];
	pol_coefficients.push_front(1);

	if (!(R_IsNA(tr_left(0, 0))) & !(R_IsNA(tr_right(0, 0))))
	{

		return((1 - 2 * is_minus) * sum(log(dtrhpa(x,
			tr_left, tr_right,
			pol_coefficients, pol_degrees,
			given_ind, omit_ind,
			mean, sd))));
	}

	return((1 - 2 * is_minus) * sum(log(dhpa(x,
		pol_coefficients, pol_degrees,
		given_ind, omit_ind,
		mean, sd))));
}

//' Predict function for hpaML
//' @param model Object of class "hpaML"
//' @template newdata_Template
//' @export	
// [[Rcpp::export(predict.hpaML)]]
NumericVector predict_ML(List model, NumericMatrix newdata = NumericMatrix(1,1)) {
	
	//Load additional environments
	Rcpp::Environment stats_env("package:stats");
	Rcpp::Function na_omit_R = stats_env["na.omit"];

	//get distribution parameters

	NumericVector pol_coefficients = model["pol_coefficients"];
	NumericVector pol_degrees = model["pol_degrees"];

	NumericVector mean = model["mean"];
	NumericVector sd = model["sd"];

	NumericMatrix tr_left = model["tr_left"];
	NumericMatrix tr_right = model["tr_right"];

	LogicalVector omit_ind = model["omit_ind"];
	LogicalVector given_ind = model["given_ind"];

	NumericMatrix x = model["data"];

	//get data
	if ((newdata.ncol() == 1) & (newdata.nrow() == 1))
	{
		newdata = x;
	} else 
	{
		newdata = na_omit_R(newdata);
	}

	//estimate
	if (!(R_IsNA(tr_left(0, 0))) & !(R_IsNA(tr_right(0, 0))))
	{
		return(dtrhpa(newdata,
			tr_left, tr_right,
			pol_coefficients, pol_degrees,
			given_ind, omit_ind,
			mean, sd));
	}

	return(dhpa(newdata,
		pol_coefficients, pol_degrees,
		given_ind, omit_ind,
		mean, sd));
}

//' Summary for hpaML output
//' @param model Object of class "hpaML"
//' @return \link[hpa]{hpaML}
//' @export	
// [[Rcpp::export(summary.hpaML)]]
List summary_ML(List model) {
	List return_result = clone(model); //in order to preserve model class
	return_result.attr("class") = "hpaML.summary";
	return(return_result);
}

//' Summary for hpaML output
//' @param model Object of class "hpaML"
//' @export	
// [[Rcpp::export(print.hpaML.summary)]]
void print_summary_ML(List model) {

	//Load additional environments
	Rcpp::Environment base_env("package:base");
	Rcpp::Function as_table = base_env["as.table"];
	Rcpp::Function cbind = base_env["cbind"];
	Rcpp::Function round_R = base_env["round"];

	NumericMatrix results = model["results"];
	results = round_R(Rcpp::_["x"] = results, Rcpp::_["digits"] = 5);

	NumericVector x1 = model["x1"];

	NumericVector p_values = results(_, 2);

	StringVector stars = starVector(p_values);

	double lnL = model["log-likelihood"];
	double AIC = model["AIC"];
	int n_obs = model["n_obs"];
	int df = x1.size();
	std::string lnL_string = "Log-Likelihood: " + std::to_string(lnL) + "\n";
	std::string AIC_string = "AIC: " + std::to_string(AIC) + "\n";
	std::string n_obs_string = "Observations " + std::to_string(n_obs) + "\n";
	std::string df_string = std::to_string(df) + " free parameters (df = " + std::to_string(n_obs - df) + ")" + "\n";

	Rprintf("%s", "--------------------------------------------\n");

	Rprintf("%s", "Semi-nonparametric maximum likelihood estimation\n");

	std::printf("%s", lnL_string.c_str());
	std::printf("%s", AIC_string.c_str());
	std::printf("%s", n_obs_string.c_str());
	std::printf("%s", df_string.c_str());

	Rprintf("%s", "Distribution parameters:\n");
	print(as_table(cbind(results, stars)));

	Rprintf("%s", "---\n");
	Rprintf("%s", "Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1\n");

	Rprintf("%s", "--------------------------------------------");
}

//' Create star vector
// [[Rcpp::export(starVector)]]
StringVector starVector(NumericVector p_values)
{
	int n = p_values.size();

	StringVector stars(n);

	for (int i = 0; i < n; i++)
	{
		if (!NumericVector::is_na(p_values[i]))
		{
			if (p_values[i] <= 0.001)
			{
				stars[i] = "***";
			} else
			{
				if (0.001 < p_values[i] <= 0.01)
				{
					stars[i] = "**";
				} else
				{
					if (0.01 < p_values[i] <= 0.05)
					{
						stars[i] = "*";
					} else
					{
						if (0.05 < p_values[i] <= 0.1)
						{
							stars[i] = ".";
						} else
						{
							if (0.1 < p_values[i] <= 1)
							{
								stars[i] = " ";
							}
						}
					}
				}
			}
		}
		else
		{
			stars[i] = " ";
		}
	}

	return(stars);
}