#include "hpaMain.h"
#include "hpaML.h"
#include "hpaHeckman.h"
#include "hpaBinary.h"
#include "polynomialIndex.h"

#include <RcppArmadillo.h>
using namespace RcppArmadillo;

//[[Rcpp::depends(RcppArmadillo)]]


//' Perform maximum likelihood estimation for Phillips-Gallanth-Nychka distribution
//' @export	
// [[Rcpp::export]]
Rcpp::List hpaHeckman(Rcpp::Formula selection,
	Rcpp::Formula outcome,
	DataFrame data,
	int z_K = 1,
	int y_K = 1,
	int pol_elements = 3,
	NumericVector x0 = NumericVector(0)) {

	//Load additional environments

	//Add in future
	//Rcpp::Environment stats_env("package:optimParallel");
	//Rcpp::Function optim = stats_env["optimParallel"];

	Rcpp::Environment stats_env("package:stats");
	Rcpp::Function optim = stats_env["optim"];
	Rcpp::Function model_frame = stats_env["model.frame"];
	Rcpp::Function na_omit_R = stats_env["na.omit"];
	Rcpp::Function glm = stats_env["glm"];
	Rcpp::Function binomial = stats_env["binomial"];
	Rcpp::Function na_pass = stats_env["na.pass"];
	Rcpp::Function dt_R = stats_env["dt"];
	Rcpp::Function pt_R = stats_env["pt"];

	Rcpp::Environment base_env("package:base");
	Rcpp::Function solve = base_env["solve"];
	Rcpp::Function class_R = base_env["class"];

	//Remove NA values

	//data = na_omit_R(data);

	//Initialize polynomial structure related values

	int pol_coefficients_n = (z_K + 1) * (y_K + 1) - 1; //-1 because of restriction a(0...0)=1

	NumericVector pol_degrees = {(double)z_K, (double)y_K};

	NumericMatrix polIndex_mat = polynomialIndex(pol_degrees);

	//Working with Data

		//Extract dataframe from formula

	DataFrame z_df = model_frame(Rcpp::_["formula"] = selection, Rcpp::_["data"] = data, Rcpp::_["na.action"] = na_pass);
	DataFrame y_df = model_frame(Rcpp::_["formula"] = outcome, Rcpp::_["data"] = data, Rcpp::_["na.action"] = na_pass);

	CharacterVector z_df_names = z_df.names();
	CharacterVector y_df_names = y_df.names();

	int z_df_n = z_df.size();
	int y_df_n = y_df.size();

		//Extract dependend variables

	NumericVector z = z_df[0]; //it is reference
	NumericVector y = y_df[0]; //it is reference

	int n = z.size();

	//Extract independend variable

	NumericMatrix z_d(n, z_df_n - 1);//-1 because there is no constant term
	NumericMatrix y_d(n, y_df_n - 1);//-1 because there is no constant term

	int z_d_col = z_d.ncol();
	int y_d_col = y_d.ncol();

	for (int i = 0; i < z_d_col; i++)
	{
		z_d(_, i) = NumericVector(z_df[i+1]);
	}
	for (int i = 0; i < y_d_col; i++)
	{
		y_d(_, i) = NumericVector(y_df[i + 1]);
	}

	//Create initial values vector
	bool x0_given = true;

	if (x0.size() == 0)
	{
		x0_given = false;
		x0 = NumericVector(pol_coefficients_n + 2 + z_d_col + y_d_col); //+2 for mean and sd
	}

	//Assign indexes

		//Initialize additional index and upper value for some loops

	int lower_ind = 0;

	int upper_ind = pol_coefficients_n;

		//for polynomial coefficients

	NumericVector pol_coefficients_ind(pol_coefficients_n);

	for (int i = lower_ind; i < upper_ind; i++)
	{
		pol_coefficients_ind[i] = i;
	}

		//for mean vector
	
	int z_mean_ind = pol_coefficients_n;
	int y_mean_ind = z_mean_ind + 1;

		//for sd vector

	int y_sd_ind;

	y_sd_ind = y_mean_ind + 1;

		//for z coefficients

	NumericVector z_coef_ind(z_d_col - 1);

	lower_ind = y_sd_ind + 1;

	upper_ind = lower_ind + z_d_col - 1;

	for (int i = lower_ind; i < upper_ind; i++)
	{
		z_coef_ind[i - lower_ind] = i;
	}

		//for y coefficients

	NumericVector y_coef_ind(y_d_col);

	lower_ind = upper_ind;

	upper_ind = lower_ind + y_d_col;

	for (int i = lower_ind; i < upper_ind; i++)
	{
		y_coef_ind[i - lower_ind] = i;
	}

	//Convert to arma

	arma::vec y_arma = as<arma::vec>(y);

	arma::vec z_arma = as<arma::vec>(z);

	arma::mat y_d_arma = as<arma::mat>(y_d);

	arma::mat z_d_arma = as<arma::mat>(z_d);

	//Divide into observable and unobservable samples

		//observable

	arma::vec y_1 = as<arma::vec>(y[z == 1]);
	
	int n_1 = y_1.size();

	arma::mat y_d_1 = (as<arma::mat>(y_d)).rows(arma::find(z_arma == 1));

	arma::vec z_1 = as<arma::vec>(z[z == 1]);

	arma::mat z_d_1 = (as<arma::mat>(z_d)).rows(arma::find(z_arma == 1));

		//unobservable

	arma::vec y_0 = as<arma::vec>(y[z == 0]);

	int n_0 = y_0.size();

	arma::mat y_d_0 = (as<arma::mat>(y_d)).rows(arma::find(z_arma == 0));

	arma::vec z_0 = as<arma::vec>(z[z == 0]);

	arma::mat z_d_0 = (as<arma::mat>(z_d)).rows(arma::find(z_arma == 0));

	List Newey;
	double z_sd = 1;

	//Get initial values from hpaBinary and Newey
	if (!x0_given)
	{
		//for hpaBinary
		List modelBinary;
		try
		{
			modelBinary = hpaBinary(selection,
				data, z_K,
				NA_REAL, 1, 0,
				true, true, true, NumericVector(0));
		}
		catch (std::exception &ex)
		{
			warning("Can't get initial values from binary choice model");
			forward_exception_to_r(ex);
		}

		List modelBinary_K = modelBinary[z_K];

		NumericVector z_pol_coef_temporal = modelBinary_K["pol_coefficients"];

		int z_pol_ind = 1;
		for (int i = 1; i < pol_coefficients_n; i++)
		{
			if (polIndex_mat(1, i) == 0)
			{
				x0[pol_coefficients_ind[i - 1]] = z_pol_coef_temporal[z_pol_ind];
				z_pol_ind++;
			}
		}

		NumericVector z_coef_temporal = modelBinary_K["coefficients"];
		NumericVector z_coef_ind_temporal = z_coef_temporal[Rcpp::Range(1, z_d_col - 1)];
		x0[z_coef_ind] = z_coef_ind_temporal;
		x0[z_mean_ind] = modelBinary_K["mean"];
		z_sd = modelBinary_K["sd"];

		NumericVector z_latent = wrap(z_d_arma * as<arma::vec>(z_coef_temporal));
		double z_exp = modelBinary_K["E(z_e)"];
		double z_var = modelBinary_K["Var(z_e)"];
		z_latent = (z_latent - z_exp) / sqrt(z_var); //standartize for mills ratio

		NumericVector z_latent_1 = z_latent[z == 1];
		NumericVector z_latent_0 = z_latent[z == 0];


		//Newey with 3 approximating polynomial elements

			//prepare data

		arma::mat y_d_1_Newey = arma::mat(y_1.size(), y_d_col + pol_elements + 1, arma::fill::ones);
		
		NumericMatrix z_mills = NumericMatrix(n_1, pol_elements + 1);

		for (int i = 0; i < y_d_col; i++)
		{
			y_d_1_Newey.col(i) = y_d_1.col(i);
		}
		for (int i = y_d_col; i < (y_d_col + pol_elements + 1); i++)
		{
			NumericVector z_mills_temporal = dnorm(z_latent_1) / pnorm(z_latent_1);
			z_mills(_, i-y_d_col) = pow(z_mills_temporal, i - y_d_col);
			z_mills_temporal = z_mills(_, i - y_d_col);
			y_d_1_Newey.col(i) = as<arma::vec>(z_mills_temporal);
		}
		//estimate coefficients

		arma::mat y_coef_Newey_arma;
		y_coef_Newey_arma = inv(y_d_1_Newey.t() * y_d_1_Newey) * y_d_1_Newey.t() * y_1;

		NumericVector y_coef_Newey = wrap(y_coef_Newey_arma);

		//assign coefficients to x0

		NumericVector y_coef_Newey_temporal = y_coef_Newey[Rcpp::Range(0, y_d_col - 1)];

		x0[y_coef_ind] = y_coef_Newey_temporal;

		x0[y_mean_ind] = y_coef_Newey[y_d_col];

		arma::mat predictions_ls = y_d_1_Newey * y_coef_Newey_arma - y_1;
		arma::mat residuals = predictions_ls.t() * predictions_ls;
		x0[y_sd_ind] = sqrt(residuals(0, 0) / (n_1 - 1 - y_d_col));

		//get additional values for inverse mills ratios

		NumericVector y_coef_Newey_mills = y_coef_Newey[Rcpp::Range(y_d_col, y_d_col + pol_elements)];

		NumericVector z_expect = NumericVector(n_1);

		for (int i = 0; i < (pol_elements + 1); i++)
		{
			z_expect = z_expect + y_coef_Newey_mills[i] * z_mills(_, i);
		}

		//summarize output for Newey

		Newey = List::create(Named("coefficients") = y_coef_Newey_temporal,
			Named("constant_biased") = x0[y_mean_ind], 
			Named("sd_biased") = x0[y_sd_ind],
			Named("inv_mills") = z_mills,
			Named("inv_mills_coef") = y_coef_Newey_mills,
			Named("E(e|z>0)") = z_expect);
	}

	//Create list for some variables because unfortunatelly optim function has limitation for the
	//parameters number (parameters itself not estimated)

	List ind_List = List::create(Named("pol_coefficients_ind") = pol_coefficients_ind,
		Named("z_mean_ind") = z_mean_ind,
		Named("y_mean_ind") = y_mean_ind,
		Named("y_sd_ind") = y_sd_ind,
		Named("y_coef_ind") = y_coef_ind,
		Named("z_coef_ind") = z_coef_ind
	);

	//Apply optimization routine

	List PGN_control = List::create(Named("maxit") = 1000000);

	List optim_results = optim(
		Rcpp::_["par"] = x0,
		Rcpp::_["fn"] = Rcpp::InternalFunction(&hpaHeckmanLnLOptim),
		Rcpp::_["control"] = PGN_control,
		Rcpp::_["method"] = "BFGS",
		Rcpp::_["hessian"] = true,
		Rcpp::_["ind_List"] = ind_List,
		Rcpp::_["y_1"] = y_1,
		Rcpp::_["y_0"] = y_0,
		Rcpp::_["z_1"] = z_1,
		Rcpp::_["z_0"] = z_0,
		Rcpp::_["y_d_1"] = y_d_1,
		Rcpp::_["y_d_0"] = y_d_0,
		Rcpp::_["z_d_1"] = z_d_1,
		Rcpp::_["z_d_0"] = z_d_0,
		Rcpp::_["pol_degrees"] = pol_degrees,
		Rcpp::_["z_sd"] = z_sd,
		Rcpp::_["is_minus"] = true); //true because of minimization);

	//calculate additional values

		//get vector of estimated values

	NumericVector x1 = optim_results["par"];

	int x1_n = x1.size();

		//calcukate log-likelihood and AIC

	double lnL = optim_results["value"];

	lnL = lnL * (-1);

	double AIC = 2 * (x1_n - lnL);

		//get polynomial coefficients

	NumericVector pol_coefficients = NumericVector(pol_coefficients_n);

	if ((z_K != 0) | (y_K != 0))
	{
		pol_coefficients = x1[pol_coefficients_ind];
	}

	pol_coefficients.push_front(1);

		//get mean and sd values
	double z_mean = x1[z_mean_ind];
	double y_mean = x1[y_mean_ind];
	double y_sd = x1[y_sd_ind];

		//get coefficients

	NumericVector z_coef = x1[z_coef_ind];
	NumericVector y_coef = x1[y_coef_ind];

		//get covariance matrix

	NumericMatrix cov_mat = solve(optim_results["hessian"]);

	//Prepare beautifull results output

	NumericMatrix results(x1_n, 4);

	StringVector results_cols = StringVector::create("Estimate", "Std. Error", "z value", "P(>|z|)");

	StringVector results_rows(x1_n);

	//polIndex_mat

		//for alpha

	double z_stat = 0;
	NumericVector F_z_stat;
	for (int i = 1; i <= pol_coefficients_n; i++)
	{
		results_rows[(i - 1)] = "a_" + std::to_string((int)polIndex_mat(0, i)) + "_" + std::to_string((int)polIndex_mat(1, i));
		results((i - 1), 0) = pol_coefficients[(i - 1) + 1];
		results((i - 1), 1) = sqrt(cov_mat((i - 1), (i - 1)));
		z_stat = results((i - 1), 0) / results((i - 1), 1);
		F_z_stat = pnorm(NumericVector::create(z_stat));
		results((i - 1), 2) = z_stat;
		results((i - 1), 3) = 2 * std::min(F_z_stat[0], 1 - F_z_stat[0]);
	}

		//for z_mean
		
	results_rows[z_mean_ind] = "z_mean";
	results(z_mean_ind, 0) = x1[z_mean_ind];
	results(z_mean_ind, 1) = sqrt(cov_mat((z_mean_ind - 1), (z_mean_ind - 1)));
	z_stat = results(z_mean_ind, 0) / results(z_mean_ind, 1);
	F_z_stat = pnorm(NumericVector::create(z_stat));
	results(z_mean_ind, 2) = z_stat;
	results(z_mean_ind, 3) = 2 * std::min(F_z_stat[0], 1 - F_z_stat[0]);

		//for y_mean

	results_rows[y_mean_ind] = "y_mean";
	results(y_mean_ind, 0) = x1[y_mean_ind];
	results(y_mean_ind, 1) = sqrt(cov_mat((y_mean_ind - 1), (y_mean_ind - 1)));
	z_stat = results(y_mean_ind, 0) / results(y_mean_ind, 1);
	F_z_stat = pnorm(NumericVector::create(z_stat));
	results(y_mean_ind, 2) = z_stat;
	results(y_mean_ind, 3) = 2 * std::min(F_z_stat[0], 1 - F_z_stat[0]);

		//for y_sd

	results_rows[y_sd_ind] = "y_sd";
	results(y_sd_ind, 0) = x1[y_sd_ind];
	results(y_sd_ind, 1) = sqrt(cov_mat((y_sd_ind - 1), (y_sd_ind - 1)));
	z_stat = results(y_sd_ind, 0) / results(y_sd_ind, 1);
	F_z_stat = pnorm(NumericVector::create(z_stat));
	results(y_sd_ind, 2) = z_stat;
	results(y_sd_ind, 3) = 2 * std::min(F_z_stat[0], 1 - F_z_stat[0]);

		//for z coefficients

	for (int i = 0; i < (z_d_col - 1); i++)
	{
		results_rows[z_coef_ind[i]] = z_df_names(i + 2);
		results(z_coef_ind[i], 0) = x1[z_coef_ind[i]];
		results(z_coef_ind[i], 1) = sqrt(cov_mat(z_coef_ind[i], z_coef_ind[i]));
		z_stat = results(z_coef_ind[i], 0) / results(z_coef_ind[i], 1);
		F_z_stat = pnorm(NumericVector::create(z_stat));
		results(z_coef_ind[i], 2) = z_stat;
		results(z_coef_ind[i], 3) = 2 * std::min(F_z_stat[0], 1 - F_z_stat[0]);
	}

		//for y coefficients

	for (int i = 0; i < y_d_col; i++)
	{
		results_rows[y_coef_ind[i]] = y_df_names(i + 1);
		results(y_coef_ind[i], 0) = x1[y_coef_ind[i]];
		results(y_coef_ind[i], 1) = sqrt(cov_mat(y_coef_ind[i], y_coef_ind[i]));
		double z_stat = results(y_coef_ind[i], 0) / results(y_coef_ind[i], 1);
		F_z_stat = pnorm(NumericVector::create(z_stat));
		results(y_coef_ind[i], 2) = z_stat;
		results(y_coef_ind[i], 3) = 2 * std::min(F_z_stat[0], 1 - F_z_stat[0]);
	}

		//assign names to the output

	rownames(results) = results_rows;

	colnames(results) = results_cols;

	//Calculate expectation and variance
	NumericVector z_e = ehpa(NumericMatrix(1, 1), pol_coefficients, pol_degrees,
		LogicalVector{false, false}, LogicalVector{false, false},
		NumericVector::create(z_mean, y_mean), NumericVector::create(z_sd, y_sd),
		NumericVector::create(1, 0));

	NumericVector z_e_2 = ehpa(NumericMatrix(1, 1), pol_coefficients, pol_degrees,
		LogicalVector{false, false}, LogicalVector{false, false},
		NumericVector::create(z_mean, y_mean), NumericVector::create(z_sd, y_sd),
		NumericVector::create(2, 0));

	NumericVector y_e = ehpa(NumericMatrix(1, 1), pol_coefficients, pol_degrees,
		LogicalVector{false, false}, LogicalVector{false, false},
		NumericVector::create(z_mean, y_mean), NumericVector::create(z_sd, y_sd),
		NumericVector::create(0, 1));

	NumericVector y_e_2 = ehpa(NumericMatrix(1, 1), pol_coefficients, pol_degrees,
		LogicalVector{false, false}, LogicalVector{false, false},
		NumericVector::create(z_mean, y_mean), NumericVector::create(z_sd, y_sd),
		NumericVector::create(0, 2));

	NumericVector z_y_e = ehpa(NumericMatrix(1, 1), pol_coefficients, pol_degrees,
		LogicalVector{false, false}, LogicalVector{false, false},
		NumericVector::create(z_mean, y_mean), NumericVector::create(z_sd, y_sd),
		NumericVector::create(1, 1));

	double z_v = z_e_2[0] - z_e[0] * z_e[0];
	double y_v = y_e_2[0] - y_e[0] * y_e[0];
	double z_y_c = z_y_e[0] - z_e[0] * y_e[0];
	double rho = z_y_c / sqrt(z_v * y_v);


	//NumericVector z_e_2 = ehpa(NumericMatrix(1, 1), pol_coefficients, NumericVector::create(K),
	//	LogicalVector::create(0), LogicalVector::create(0),
	//	z_mean, z_sd,
	//	NumericVector::create(2));

	//
	//
	//

	List return_list = List::create(Named("optim") = optim_results,
		Named("Newey") = Newey,
		Named("logLik") = lnL,
		Named("AIC") = AIC,
		Named("data_z") = y_df,
		Named("data_y") = z_df,
		Named("results") = results,
		Named("z_mean") = z_mean,
		Named("y_mean") = y_mean, 
		Named("z_sd") = z_sd, 
		Named("y_sd") = y_sd,
		Named("pol_coefficients") = pol_coefficients,
		Named("E(z*|X)") = z_e,
		Named("E(y|X)") = y_e,
		Named("Var(z*|X)") = z_v,
		Named("Var(y|X)") = y_v,
		Named("Cov(z,y|X)") = z_y_c,
		Named("rho") = rho);

	return(return_list);
}

//' Perform  log-likelihood function estimation for phillips-gallant-nychka distribution at point
// [[Rcpp::export]]
double hpaHeckmanLnLOptim(NumericVector x0,
	List ind_List,
	arma::vec y_1,
	arma::vec y_0,
	arma::vec z_1,
	arma::vec z_0,
	arma::mat y_d_1,
	arma::mat y_d_0,
	arma::mat z_d_1,
	arma::mat z_d_0,
	NumericVector pol_degrees,
	double z_sd,
	bool is_minus = false)
{
	//Get values from the list

	NumericVector pol_coefficients_ind = ind_List["pol_coefficients_ind"];
	int z_mean_ind = ind_List["z_mean_ind"];
	int y_mean_ind = ind_List["y_mean_ind"];
	int y_sd_ind = ind_List["y_sd_ind"];
	NumericVector z_coef_ind = ind_List["z_coef_ind"];
	NumericVector y_coef_ind = ind_List["y_coef_ind"];
	

	//Assign estimated parameters values to corresponding vectors

		//polynomial coefficients and degrees
	NumericVector pol_coefficients = x0[pol_coefficients_ind];
	pol_coefficients.push_front(1); //add alpha(0...0)

		//mean
	double z_mean = x0[z_mean_ind];
	double y_mean = x0[y_mean_ind];
	NumericVector mean = {z_mean, y_mean};

		//sd
	double y_sd = x0[y_sd_ind];
	NumericVector sd = {z_sd, y_sd};

	if (y_sd <= 0)
	{
		return(999999999);
	}

		//coefficients for independend variables

	arma::vec y_coef = as<arma::vec>(x0[y_coef_ind]);
	NumericVector z_coef_temporal = x0[z_coef_ind];
	z_coef_temporal.push_front(1); //for fixed coefficient
	arma::vec z_coef = as<arma::vec>(z_coef_temporal);

		//get estimates for z*

	NumericVector z_h_1 = wrap(z_d_1 * z_coef);

	NumericVector z_h_0 = wrap(z_d_0 * z_coef);

		//get estimates for y and random errors

	arma::mat y_h_1 = y_d_1 * y_coef;

	NumericVector e_h_1 = wrap(y_1 - y_h_1);

	//concatenate e_h and z_h and prepare to insert into function

	NumericMatrix z_y_1 = NumericMatrix(z_h_1.size(), 2);
	NumericMatrix z_y_0 = NumericMatrix(z_h_0.size(), 2);

	z_y_1(_, 0) = (-1) * z_h_1;
	z_y_1(_, 1) = e_h_1;

	z_y_0(_, 0) = (-1) * z_h_0;

	//likelihood calculation

	double lnL_y_1 = 0;

	double lnL_z_y_1 = 0;

	double lnL_z_y_0 = 0;

	lnL_y_1 = (1 - 2 * is_minus) * sum(log(dhpa(z_y_1,
		pol_coefficients, pol_degrees,
		LogicalVector{false, false}, LogicalVector{true, false},
		mean, sd)));

	lnL_z_y_1 = (1 - 2 * is_minus) * sum(log(1 - phpa(z_y_1,
		pol_coefficients, pol_degrees,
		LogicalVector{false, true}, LogicalVector{false, false},
		mean, sd)));

	lnL_z_y_0 = (1 - 2 * is_minus) * sum(log(phpa(z_y_0,
		pol_coefficients, pol_degrees,
		LogicalVector{false, false}, LogicalVector{false, true},
		mean, sd)));

	return(lnL_y_1 + lnL_z_y_1 + lnL_z_y_0);
}

//' Predict probabilities from hpaBinary model
//' @export	
// [[Rcpp::export(predict.hpaHeckmam)]]
NumericVector predict(List model, DataFrame newdata = R_NilValue)
{

}