#include "hpaMain.h"
#include "hpaBinary.h"
#include "polynomialIndex.h"

#include <RcppArmadillo.h>
using namespace RcppArmadillo;

// [[Rcpp::depends(RcppArmadillo)]]


//' Perform binary choice model estimation under random errors 
//' Phillips-Gallanth-Nychka distribution assumption
//' @template formula_Template
//' @template data_Template
//' @template K_Template
//' @template z_mean_fixed_Template
//' @template z_sd_fixed_Template
//' @template z_constant_fixed_Template
//' @template z_coef_first_fixed_Template
//' @template x0_binary_Template
//' @template is_sequence_Template
//' @export	
// [[Rcpp::export]]
List hpaBinary(Rcpp::Formula formula,
	DataFrame data,
	int K = 1,
	double z_mean_fixed = NA_REAL,
	double z_sd_fixed = NA_REAL,
	double z_constant_fixed = 0,
	bool is_z_coef_first_fixed = true,
	NumericVector x0 = NumericVector(0),
	bool is_sequence = false) {

	//Load additional environments

	//Add in future
	//Rcpp::Environment stats_env("package:optimParallel");
	//Rcpp::Function optim = stats_env["optimParallel"];

	Rcpp::Environment stats_env("package:stats");
	Rcpp::Function optim = stats_env["optim"];
	Rcpp::Function model_frame = stats_env["model.frame"];
	Rcpp::Function na_omit_R = stats_env["na.omit"];

	Rcpp::Environment base_env("package:base");
	Rcpp::Function solve = base_env["solve"];
	
	//Remove NA values

	data = na_omit_R(data);

	//Initialize polynomial structure related values

	int pol_coefficients_n = K;

	//Initialize bool values related to fixed parameters

	bool is_z_mean_fixed = !R_IsNA(z_mean_fixed);

	bool is_z_sd_fixed = !R_IsNA(z_sd_fixed);

	bool is_z_constant_fixed = !R_IsNA(z_constant_fixed);

	//Working with Data

		//Extract dataframe from formula

	DataFrame z_df = model_frame(Rcpp::_["formula"] = formula, Rcpp::_["data"] = data);

	int z_df_n = z_df.size();

		//Extract binary dependend variable
	 
	NumericVector z = z_df[0]; //it is reference

	int n = z.size();

		//Extract independend variable

	NumericMatrix z_d(n, z_df_n - is_z_constant_fixed);

	if (!is_z_constant_fixed)
	{
		z_d(_, 0) = (NumericVector(n) + 1); //add constant
	}

	for (int i = 1 * is_z_constant_fixed; i < z_df_n; i++)
	{
		z_d(_, i - is_z_constant_fixed) = as<NumericVector>(z_df[i]);
	}

	int z_d_col = z_d.ncol();

	//Sequential estimation
	if (is_sequence)
	{
		//for K=0
		List results(K + 1);
		results[0] = hpaBinary(formula, data, 0, z_mean_fixed, z_sd_fixed, z_constant_fixed, is_z_coef_first_fixed);
		List results_current = results[0];
		NumericVector x1 = results_current["x1"];
		int x0_n = x1.size() + 1; //add one more alpha parameter for the next estimation
		NumericVector x0 = NumericVector(x0_n);
		for (int i = 1; i < x0_n; i++)
		{
			x0[i] = x1[i - 1];
		}
		//for other K
		for (int i = 1; i <= K; i++)
		{
			results[i] = hpaBinary(formula, data, i, z_mean_fixed, z_sd_fixed, z_constant_fixed, is_z_coef_first_fixed, x0, false);
			results_current = results[i];
			x1 = results_current["x1"];
			x0_n++;
			x0 = NumericVector(x0_n);
			for (int j = 0; j < x0_n; j++)
			{
				if (i > j)
				{
					x0[j] = x1[j];
				}
				if (i < j)
				{
					x0[j] = x1[j - 1];
				}
			}
		}
		return(results);
	}

	//Create initial values vector
	bool x0_given = true;

	if (x0.size() == 0)
	{
		x0_given = false;
		//x0 dimensions are equal to the estimated (nonfixed) parameters number
		x0 = NumericVector(pol_coefficients_n +
							!is_z_mean_fixed + !is_z_sd_fixed +
							z_d_col - is_z_coef_first_fixed + !is_z_constant_fixed
		);
	}

	//Assign indexes

		//Initialize additional index and upper value for some loops

	int k = 0; //to account for fixed parameters

	int lower_ind = 0;

	int upper_ind = pol_coefficients_n;

		//for polynomial coefficients

	NumericVector pol_coefficients_ind(pol_coefficients_n);

	if (K != 0)
	{
		for (int i = lower_ind; i < upper_ind; i++)
		{
			pol_coefficients_ind[i] = i;
		}
	} else {
		pol_coefficients_ind = NumericVector::create(0);
	}
		//for mean vector

	int z_mean_ind = 0;

	if (!is_z_mean_fixed)
	{
		z_mean_ind = pol_coefficients_n + k;
		k++;
	}

		//for sd vector
	int z_sd_ind = 0;

	if (!is_z_sd_fixed)
	{
		z_sd_ind = pol_coefficients_n + k;
		k++;
	}

		//for z coefficients

	NumericVector z_coef_ind(z_d_col + !is_z_constant_fixed - is_z_coef_first_fixed);

	lower_ind = pol_coefficients_n + k;

	upper_ind = pol_coefficients_n + z_coef_ind.size() + k;

	for (int i = lower_ind; i < upper_ind; i++)
	{
		z_coef_ind[i - lower_ind] = i;
	}

	//Convert to arma

	arma::vec z_arma = as<arma::vec>(z);

	arma::mat z_d_arma = as<arma::mat>(z_d);

	//Divide into 0 and 1 samples

	arma::vec z_1 = as<arma::vec>(z[z == 1]);

	arma::mat z_d_1 = (as<arma::mat>(z_d)).rows(arma::find(z_arma == 1));

	arma::vec z_0 = as<arma::vec>(z[z == 0]);

	arma::mat z_d_0 = (as<arma::mat>(z_d)).rows(arma::find(z_arma == 0));

	//set initial sd value to 1

	if (!is_z_sd_fixed & !x0_given)
	{
		x0[z_sd_ind] = 1;
	}

	//Create list for some variables because unfortunatelly optim function has limitation for the
	//parameters number (parameters itself not estimated)

	List is_List = List::create(Named("is_z_coef_first_fixed") = is_z_coef_first_fixed, 
		Named("is_z_mean_fixed") = is_z_mean_fixed,
		Named("is_z_sd_fixed") = is_z_sd_fixed,
		Named("is_z_constant_fixed") = is_z_constant_fixed
	);

	//Apply optimization routine

	List PGN_control = List::create(Named("maxit") = 1000000);

	List optim_results = optim(
		Rcpp::_["par"] = x0,
		Rcpp::_["fn"] = Rcpp::InternalFunction(&hpaBinaryLnLOptim),
		Rcpp::_["control"] = PGN_control,
		Rcpp::_["method"] = "BFGS",
		Rcpp::_["hessian"] = true,
		Rcpp::_["is_List"] = is_List,
		Rcpp::_["z_1"] = z_1,
		Rcpp::_["z_0"] = z_0,
		Rcpp::_["z_d_1"] = z_d_1,
		Rcpp::_["z_d_0"] = z_d_0,
		Rcpp::_["K"] = K,
		Rcpp::_["z_mean_fixed"] = z_mean_fixed,
		Rcpp::_["z_sd_fixed"] = z_sd_fixed,
		Rcpp::_["z_constant_fixed"] = z_constant_fixed,
		Rcpp::_["pol_coefficients_ind"] = pol_coefficients_ind,
		Rcpp::_["z_mean_ind"] = z_mean_ind,
		Rcpp::_["z_sd_ind"] = z_sd_ind,
		Rcpp::_["z_coef_ind"] = z_coef_ind,
		Rcpp::_["is_minus"] = true); //true because of minimization);

	//extract coefficients and covariance matrix

	NumericVector x1 = optim_results["par"];

	double optim_value = optim_results["value"];

	int x1_n = x0.size();

	NumericVector pol_coefficients = x1[pol_coefficients_ind];
	pol_coefficients.push_front(1);


	NumericVector z_mean = NumericVector(1);
	if(!is_z_mean_fixed)
	{ 
		z_mean = NumericVector::create(x1[z_mean_ind]);
	}
	else
	{
		z_mean = NumericVector::create(z_mean_fixed);
	}

	NumericVector z_sd = NumericVector(1);
	if (!is_z_sd_fixed)
	{
		z_sd = NumericVector::create(x1[z_sd_ind]);
	}
	else
	{
		z_sd = NumericVector::create(z_sd_fixed);
	}

	NumericVector z_coef = x1[z_coef_ind];

	NumericMatrix cov_mat = solve(optim_results["hessian"]);

	//Prepare beautifull results output

	NumericMatrix results(x1_n, 3);

	StringVector results_cols = StringVector::create("Estimate", "Std. Error", "P(>|t|)");

	StringVector results_rows(x1_n);

	NumericMatrix pol_ind = polynomialIndex(NumericVector::create(K));

		//for alpha

		for (int i = 1; i < (K+1); i++)
		{
			//Convert double to string
			std::stringstream ss;
			ss << i;
			std::string str2 = ss.str();
			//
			results_rows[i - 1] = "a_" + str2;
			results((i - 1), 0) = pol_coefficients[i];
			results((i - 1), 1) = sqrt(cov_mat((i - 1), (i - 1)));
			double t_stat = results((i - 1), 0) / results((i - 1), 1);
			NumericVector F_t_stat = pnorm(NumericVector::create(t_stat));
			results((i - 1), 2) = 2 * std::min(F_t_stat[0], 1 - F_t_stat[0]);
		}

		//for mean
	if (!is_z_mean_fixed)
	{
		results_rows[z_mean_ind] = "mean";
		results(z_mean_ind, 0) = x1[z_mean_ind];
		results(z_mean_ind, 1) = sqrt(cov_mat((z_mean_ind - 1), (z_mean_ind - 1)));
		double t_stat = results(z_mean_ind, 0) / results(z_mean_ind, 1);
		NumericVector F_t_stat = pnorm(NumericVector::create(t_stat));
		results(z_mean_ind, 2) = 2 * std::min(F_t_stat[0], 1 - F_t_stat[0]);
	}

		//for sd
	if (!is_z_sd_fixed)
	{
		results_rows[z_sd_ind] = "sd";
		results(z_sd_ind, 0) = x1[z_sd_ind];
		results(z_sd_ind, 1) = sqrt(cov_mat((z_sd_ind - 1), (z_sd_ind - 1)));
		double t_stat = results(z_sd_ind, 0) / results(z_sd_ind, 1);
		NumericVector F_t_stat = pnorm(NumericVector::create(t_stat));
		results(z_sd_ind, 2) = 2 * std::min(F_t_stat[0], 1 - F_t_stat[0]);
	}
	
		//for z coefficients
	CharacterVector z_df_names = z_df.names();

	if (!is_z_constant_fixed)
	{
		int z_constant_ind = K + !is_z_mean_fixed + !is_z_sd_fixed;
		results_rows(z_constant_ind) = "(Intercept)";
		results(z_constant_ind, 0) = z_coef[0];
		results(z_constant_ind, 1) = sqrt(cov_mat(z_coef_ind[0], z_coef_ind[0]));
		double t_stat = results(z_constant_ind, 0) / results(z_constant_ind, 1);
		NumericVector F_t_stat = pnorm(NumericVector::create(t_stat));
		results(z_constant_ind, 2) = 2 * std::min(F_t_stat[0], 1 - F_t_stat[0]);
	}

	if (!is_z_coef_first_fixed)
	{
		int z_first_ind = K + !is_z_mean_fixed + !is_z_sd_fixed + !is_z_constant_fixed;
		results_rows(z_first_ind) = z_df_names[!is_z_constant_fixed + 1];
		results(z_first_ind, 0) = z_coef[!is_z_constant_fixed];
		results(z_first_ind, 1) = sqrt(cov_mat(z_coef_ind[!is_z_constant_fixed], z_coef_ind[!is_z_constant_fixed]));
		double t_stat = results(z_first_ind, 0) / results(z_first_ind, 1);
		NumericVector F_t_stat = pnorm(NumericVector::create(t_stat));
		results(z_first_ind, 2) = 2 * std::min(F_t_stat[0], 1 - F_t_stat[0]);
	}

	int z_rows_k = K + !is_z_mean_fixed + !is_z_sd_fixed + !is_z_constant_fixed + !is_z_coef_first_fixed;
	int z_names_k = !is_z_constant_fixed + !is_z_coef_first_fixed; //+1 because the first is dependend variable
	for (int i = z_rows_k; i < x1_n; i++)
	{
		results_rows(i) = z_df_names[z_names_k + 1 + is_z_coef_first_fixed];
		results(i, 0) = z_coef[z_names_k];
		results(i, 1) = sqrt(cov_mat(z_coef_ind[z_names_k], z_coef_ind[z_names_k]));
		double t_stat = results(i, 0) / results(i, 1);
		NumericVector F_t_stat = pnorm(NumericVector::create(t_stat));
		results(i, 2) = 2 * std::min(F_t_stat[0], 1 - F_t_stat[0]);
		z_names_k++;
	}

		//for expectation and variance
	NumericVector z_e = ehpa(NumericMatrix(1, 1), pol_coefficients, NumericVector::create(K),
		LogicalVector::create(false), LogicalVector::create(false),
		z_mean, z_sd, 
		NumericVector::create(1));

	NumericVector z_e_2 = ehpa(NumericMatrix(1, 1), pol_coefficients, NumericVector::create(K),
		LogicalVector::create(0), LogicalVector::create(0),
		z_mean, z_sd,
		NumericVector::create(2));

		//assign names to the output

	rownames(results) = results_rows;

	colnames(results) = results_cols;

	//Estimate latent variable and probabilities

		//coefficients for independend variables

	if (is_z_coef_first_fixed)
	{
		z_coef.push_front(1); //add identity coefficient for fixed value
		if (!is_z_constant_fixed) //change places of constant and first z_d coefficient
		{
			double z_coef_0 = z_coef[0];
			z_coef[0] = z_coef[1];
			z_coef[1] = z_coef_0;
		}
	}

	arma::vec z_coef_arma = as<arma::vec>(z_coef);

		//get estimates for z*

	NumericMatrix z_latent = wrap(z_d_arma * z_coef_arma);

	if (is_z_constant_fixed)
	{
		z_latent = z_latent + z_constant_fixed;
	}

	NumericVector z_prob = 1 - phpa((-1) * z_latent, pol_coefficients,
		NumericVector::create(K),
		LogicalVector::create(0), LogicalVector::create(0),
		z_mean, z_sd);

	//return results
	
	List ind_list = List::create(Named("pol_coefficients_ind") = pol_coefficients_ind,
		Named("z_mean_ind") = z_mean_ind,
		Named("z_sd_ind") = z_mean_ind,
		Named("z_coef_ind") = z_coef_ind);

	List return_result = List::create(Named("optim") = optim_results,
		Named("x1") = x1,
		Named("mean") = z_mean,
		Named("sd") = z_sd,
		Named("pol_coefficients") = pol_coefficients,
		Named("coefficients") = z_coef,
		Named("results") = results,
		Named("E(z_e)") = z_e[0],
		Named("Var(z_e)") = (z_e_2[0] - z_e[0] * z_e[0]),
		Named("AIC") = 2 * (x1_n + optim_results["value"]),
		Named("z_latent") = z_latent,
		Named("z_prob") = z_prob,
		Named("ind_list") = ind_list,
		Named("formula") = formula,
		Named("dataframe") = data,
		Named("is_List") = is_List);

		//estimate probabilities 

	return(return_result);
}

//' Perform  log-likelihood function estimation for phillips-gallant-nychka distribution at point
//' @export
// [[Rcpp::export]]
double hpaBinaryLnLOptim(NumericVector x0,
	List is_List,
	arma::vec z_1,
	arma::vec z_0,
	arma::mat z_d_1,
	arma::mat z_d_0,
	int K = 1,
	double z_mean_fixed = NA_REAL,
	double z_sd_fixed = NA_REAL,
	double z_constant_fixed = 0,
	NumericVector pol_coefficients_ind = NumericVector(0),
	int z_mean_ind = 1,
	int z_sd_ind = 2,
	NumericVector z_coef_ind = NumericVector(0),
	bool is_minus = false) {

	//Get values from the is_List

	bool is_z_coef_first_fixed = is_List["is_z_coef_first_fixed"];

	bool is_z_mean_fixed = is_List["is_z_mean_fixed"];

	bool is_z_sd_fixed = is_List["is_z_sd_fixed"];

	bool is_z_constant_fixed = is_List["is_z_constant_fixed"];

	//Assign estimated parameters values to corresponding vectors

		//polynomial coefficients and degrees

	NumericVector pol_coefficients = NumericVector(K);

	if (K != 0)
	{
		pol_coefficients = x0[pol_coefficients_ind];
	} 

	pol_coefficients.push_front(1);

	NumericVector pol_degrees = NumericVector(1);

	pol_degrees[0] = K;

		//mean value

	NumericVector z_mean = NumericVector(1);

	if (is_z_mean_fixed)
	{
		z_mean[0] = z_mean_fixed;
	}
	else {
		z_mean[0] = x0[z_mean_ind];
	}

		//sd value

	NumericVector z_sd = NumericVector(1);

	if (is_z_sd_fixed)
	{
		z_sd[0] = z_sd_fixed;
	}
	else {
		z_sd[0] = x0[z_sd_ind];
	}

		//coefficients for independend variables

	NumericVector z_coef_R = x0[z_coef_ind];

	if (is_z_coef_first_fixed)
	{
		z_coef_R.push_front(1); //add identity coefficient for fixed value
		if (!is_z_constant_fixed) //change places of constant and first z_d coefficient
		{
			double z_coef_0 = z_coef_R[0];
			z_coef_R[0] = z_coef_R[1];
			z_coef_R[1] = z_coef_0;
		}
	}

	arma::vec z_coef = as<arma::vec>(z_coef_R);

	//get estimates for z*

	NumericMatrix z_h_1 = wrap(-z_d_1 * z_coef);

	if (is_z_constant_fixed)
	{
		z_h_1 = z_h_1 - z_constant_fixed;
	}

	NumericMatrix z_h_0 = wrap(-z_d_0 * z_coef);

	if (is_z_constant_fixed)
	{
		z_h_0 = z_h_0 - z_constant_fixed;
	}

	//likelihood calculation

	double lnL_z_1 = 0;

	double lnL_z_0 = 0;

	lnL_z_1 = (1 - 2 * is_minus) * (sum(log(1 - phpa(z_h_1,
		pol_coefficients, pol_degrees,
		LogicalVector{false}, LogicalVector{false},
		z_mean, z_sd))));

	lnL_z_0 = (1 - 2 * is_minus) * sum(log(phpa(z_h_0,
		pol_coefficients, pol_degrees,
		LogicalVector{false}, LogicalVector{false},
		z_mean, z_sd)));

	return(lnL_z_1 + lnL_z_0);
}

//' Predict probabilities from hpaBinary model give newdata
//' @export	
// [[Rcpp::export]]
NumericVector hpaBinary_predict(List model, DataFrame newdata) {

	//Extract variables from model

	List is_List = model["is_List"];

	bool is_z_coef_first_fixed = is_List["is_z_coef_first_fixed"];

	bool is_z_mean_fixed = is_List["is_z_mean_fixed"];

	bool is_z_sd_fixed = is_List["is_z_sd_fixed"];

	bool is_z_constant_fixed = is_List["is_z_constant_fixed"];

	NumericVector pol_coefficients = model["pol_coefficients"];

	NumericVector z_mean - model["mean"];

	NumericVector z_sd - model["sd"];

	NumericVector z_coef = model["coefficients"];

	//Remove NA values

	data = na_omit_R(data);

	//Add additional environments

	Rcpp::Environment stats_env("package:stats");
	Rcpp::Function model_frame = stats_env["model.frame"];
	Rcpp::Function na_omit_R = stats_env["na.omit"];

	//Working with Data

		//Extract dataframe from formula

	DataFrame z_df = model_frame(Rcpp::_["formula"] = model["formula"], Rcpp::_["data"] = data);

	int z_df_n = z_df.size();

	//Extract binary dependend variable

	NumericVector z = z_df[0]; //it is reference

	int n = z.size();

	//Extract independend variable

	NumericMatrix z_d(n, z_df_n - is_z_constant_fixed);

	if (!is_z_constant_fixed)
	{
		z_d(_, 0) = (NumericVector(n) + 1); //add constant
	}

	for (int i = 1 * is_z_constant_fixed; i < z_df_n; i++)
	{
		z_d(_, i - is_z_constant_fixed) = as<NumericVector>(z_df[i]);
	}

	int z_d_col = z_d.ncol();

	//Estimate latent variable and probabilities

		//coefficients for independend variables

	if (is_z_coef_first_fixed)
	{
		z_coef.push_front(1); //add identity coefficient for fixed value
		if (!is_z_constant_fixed) //change places of constant and first z_d coefficient
		{
			double z_coef_0 = z_coef[0];
			z_coef[0] = z_coef[1];
			z_coef[1] = z_coef_0;
		}
	}

	arma::vec z_coef_arma = as<arma::vec>(z_coef);

	//get estimates for z*

	NumericMatrix z_latent = wrap(z_d_arma * z_coef_arma);

	if (is_z_constant_fixed)
	{
		z_latent = z_latent + z_constant_fixed;
	}

	NumericVector z_prob = 1 - phpa((-1) * z_latent, pol_coefficients,
		NumericVector::create(K),
		LogicalVector::create(0), LogicalVector::create(0),
		z_mean, z_sd);

	return(z_prob);

}
